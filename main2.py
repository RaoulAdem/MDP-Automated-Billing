#conda activate paddleocrenv

from asyncio.log import logger
from typing import Final
from telegram import ReplyKeyboardMarkup, Update, ReplyKeyboardRemove, KeyboardButton, InputMediaPhoto
from telegram.ext import Application, ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler, Updater
import os
from openai import OpenAI
import logging
import subprocess
import json
from paddleocrtesting import process_bill
import paddleocr
from paddleocr import PaddleOCR
import google.generativeai as genai
from langchain1 import *
from sqlinsert import is_present, insert_data
import mysql.connector
from base64 import b64encode, b64decode
from dotenv import load_dotenv
from topdf import to_pdf
import re

# Load Environment Variables
load_dotenv()

#TOKEN: Final = '6943990377:AAG0bItw7XqnMmLRwxAlpY3YzUwq2q2ycQw'
TOKEN: Final = os.getenv("BOT_TOKEN")

BOT_USERNAME: Final = '@Automated_billing_bot'

genai.configure(api_key='AIzaSyCAVhwRsGPM__3lskKo44qKNTTpI_IC6xY')
model = genai.GenerativeModel(model_name="gemini-pro")
chat = model.start_chat()

ocr = PaddleOCR(use_angle_cls=True, lang='en')

downloaded_path = ''
bot_flag = True
dict_responses = {}

#Commands

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("""
Welcome to Automated Billing Bot! ðŸ¤–

This bot simplifies your expense tracking by allowing you to effortlessly manage your bills and expenditures. Simply send pictures of your bills, and the bot will utilize OCR technology to extract the necessary information and store it securely in a database. You can then interact with the bot to inquire about your spending habits.

Here are the available commands:

1. /start - Begin interacting with the bot. You're already here!
2. /help - Get assistance and guidance on how to use the bot effectively.
3. /pdf - Generate a report in a PDF format.

Feel free to explore and manage your expenses effortlessly with Automated Billing Bot! If you have any questions or need assistance, don't hesitate to use the /help command. Happy tracking! ðŸ“ŠðŸ’¸
"""
)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('Send me a picture of a bill you want me to store or ask me anything about your expenses.')

async def pdf_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global bot_flag
    bot_flag=False
    await context.bot.send_message(chat_id=update.effective_chat.id,text='Generating a report in a PDF format.\nPlease write down the date you want your report to cover\n(eg., YYYY-MM-DD).')

#Responses
async def handle_photos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global downloaded_path
    global bot_flag
    user = update.message.from_user

    if filters.PHOTO.check_update(update):
        file_id = update.message.photo[-1].file_id
        unique_file_id = update.message.photo[-1].file_unique_id
        photo_name = f"{unique_file_id}.jpg"
    elif filters.Document.IMAGE and update.message.document.file_id:
        file_id = update.message.document.file_id
        _, f_ext = os.path.splitext(update.message.document.file_name)
        unique_file_id = update.message.document.file_unique_id
        photo_name = f"{unique_file_id}.{f_ext}"

    photo_file = await context.bot.get_file(file_id)
    downloaded_path = f'./temp/{photo_name}'
    await photo_file.download_to_drive(custom_path=downloaded_path)
    await context.bot.send_message(chat_id=update.effective_chat.id, text='Processing...')
    result = process_bill(downloaded_path, chat, ocr)
    await photo_file.download_to_drive(custom_path=downloaded_path)
    if result == {}:
        if os.path.exists(downloaded_path):
            os.remove(downloaded_path)
        await context.bot.send_message(chat_id=update.effective_chat.id, text="This bill does not contain enough information to be stored in the database.")
        return
    isPresent = is_present(user.id)
    if not isPresent:
        bot_flag = False
        text_result = "Feel free to correct me if any information provided is incorrect...\n"\
        f"Bill whose type is {result['category']}\n"\
        f"and generated by {result['business_name']} on {result['date']}\n"\
        f"with a check ID of {result['check_id']}.\n"\
        f"The total is {result['total']} LL for:\n"
        i = 1
        while i<=len(result)-5:
            text_result = text_result + f"{result[f'item{i}']['quantity']}x {result[f'item{i}']['name']} for {result[f'item{i}']['price']} LL\n"
            i+=1
        keyboard = ReplyKeyboardMarkup([[ KeyboardButton("Yes"), KeyboardButton("No") ]], resize_keyboard=True, one_time_keyboard=True)
        await context.bot.send_message(chat_id=update.effective_chat.id,text=text_result, reply_markup=keyboard)
        await context.bot.send_message(chat_id=update.effective_chat.id,text="Are you sure you want to save this bill?")
    else:
        if os.path.exists(downloaded_path):
            os.remove(downloaded_path)
        await context.bot.send_message(chat_id=update.effective_chat.id, text="This bill has already been uploaded before, try another one.")


async def bot_reply(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    global downloaded_path
    global bot_flag
    global dict_responses
    user = update.message.from_user
    
    logger.info("Question from User: %s", update.message.text)

    if update.message.text != '' and bot_flag:
        user_input = update.message.text
        llm_reply, flag = get_response(user_input, user.id)
        if flag == 0:  # request image
            row = get_bill_image(llm_reply)
            if row:
                decoded_image = b64decode(row[0])
                with open('./temp/image.jpg', 'wb') as f:
                    f.write(decoded_image)
                await context.bot.send_message(chat_id=update.effective_chat.id, text="Here you go...")
                await context.bot.send_photo(chat_id=update.effective_chat.id, photo=open('./temp/image.jpg', 'rb'))   
            return
    elif not bot_flag:
        date_pattern = re.compile(r'^\d{4}-\d{1,2}-\d{1,2}$')
        if update.message.text == 'Yes':
            insert_data(downloaded_path, user.id)
            if os.path.exists(downloaded_path):
                os.remove(downloaded_path)
            await context.bot.send_message(chat_id=update.effective_chat.id, text="Your bill has been saved in the database.")
            bot_flag = True
        elif update.message.text == 'No':
            if os.path.exists('ocr_return.json'):
                os.remove('ocr_return.json')
            if os.path.exists(downloaded_path):
                os.remove(downloaded_path)
            await context.bot.send_message(chat_id=update.effective_chat.id, text="As requested, nothing will be saved.")
            bot_flag = True
        elif date_pattern.match(update.message.text.strip()):
            dict_responses["date"] = update.message.text
            keyboard = ReplyKeyboardMarkup([[ KeyboardButton("Restaurant"), KeyboardButton("Household"), KeyboardButton("Drugs"), KeyboardButton("Electronics"), KeyboardButton("Groceries"), KeyboardButton("All") ]], resize_keyboard=True, one_time_keyboard=True)
            await context.bot.send_message(chat_id=update.effective_chat.id,text="Please select one of the category proposed.", reply_markup=keyboard)
        elif update.message.text in ["Restaurant","Household","Drugs","Electronics","Groceries","All"]:
            dict_responses["category"] = update.message.text
            keyboard = ReplyKeyboardMarkup([[ KeyboardButton("LL - Lebanese pound"), KeyboardButton("$ - United States Dollar"), ]], resize_keyboard=True, one_time_keyboard=True)
            await context.bot.send_message(chat_id=update.effective_chat.id,text="Please select a currency.", reply_markup=keyboard)
        elif update.message.text in ["LL - Lebanese pound","$ - United States Dollar"]:
            await context.bot.send_message(chat_id=update.effective_chat.id, text="Working on it...")
            dict_responses["currency"] = update.message.text
            
            rows, total = get_bill_data(user.id, dict_responses["category"], dict_responses["date"])
            
            if not rows:
                await context.bot.send_message(chat_id=update.effective_chat.id, text="The report will not be generated as the database in empty.")
            else:
                await to_pdf(total, rows, dict_responses)
                await context.bot.send_document(chat_id=update.effective_chat.id, document=open('AutomatedPDF.pdf', 'rb'))  
            bot_flag = True
        else:
            if os.path.exists(downloaded_path):
                os.remove(downloaded_path)
            await context.bot.send_message(chat_id=update.effective_chat.id, text="Sorry, I did not understand.")
            bot_flag = True
        return
    await context.bot.send_message(chat_id=update.effective_chat.id, text=llm_reply)

async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.error and isinstance(context.error, TypeError) and "'NoneType' object is not iterable" in str(context.error):
        await context.bot.send_message(chat_id=update.effective_chat.id, text="Please provide a photo of a bill only.")
        if os.path.exists(downloaded_path):
            os.remove(downloaded_path)
    else:
        print(f'Update {update} caused error:\n{context.error}')
        if os.path.exists(downloaded_path):
            os.remove(downloaded_path)
        await context.bot.send_message(chat_id=update.effective_chat.id, text="Sorry, I cannot provide you an answer at the moment. Please, try again later...")

if __name__ == '__main__':
    print('Starting bot...')
    app = Application.builder().token(TOKEN).build()

    # Resgister Commands
    app.add_handler(CommandHandler('start', start_command))
    app.add_handler(CommandHandler('help', help_command))
    app.add_handler(CommandHandler('pdf', pdf_command))
    app.add_handler(MessageHandler(filters.Document.IMAGE | filters.PHOTO, handle_photos))
    app.add_handler(MessageHandler(filters.TEXT, bot_reply))

    #Errors
    app.add_error_handler(error)

    print('Polling...')
    app.run_polling(poll_interval=3) #check reply every 3s